#!/usr/bin/env python3
# MIT License
#
# Copyright (c) 2020 FABRIC Testbed
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Author Komal Thareja (kthare10@renci.org)
from daemon.runner import DaemonRunnerStopFailureError, DaemonRunner
from fabric.credmgr.credential_managers.oauth_credmgr import OAuthCredmgr
from fabric.credmgr import *
import signal
import sys
from functools import partial
from threading import Event
from optparse import OptionParser
import logging


sleeper = Event()


class CredMgrDaemon:
    def __init__(self, logger, cred_dir):
        self.cred_dir = cred_dir
        self.logger = logger
        self.stdin_path = '/dev/null'
        self.stdout_path = '/dev/null'
        self.stderr_path = '/dev/null'
        self.pidDir = cred_dir
        self.pidfile_path = (self.pidDir + '/' + "credmgrd.pid")
        self.pidfile_timeout = 10000

    def run(self):
        cred_mgr = OAuthCredmgr(self.cred_dir)
        # set up scan tokens loop
        while True:
            try:
                cred_mgr.scan_tokens()
            except Exception as e:
                self.logger.exception(e)
            self.logger.info('Sleeping for 60 seconds')
            sleeper.clear()
            sleeper.wait(60)


def signal_handler(logger, signum, frame):
    """
    Catch signals. Use SIGHUP as a sleep interrupt.
    Any other signals should exit the program.
    """
    if signum == signal.SIGHUP:
        logger.info('Got SIGHUP: Triggering READ of Credential Directory')
        sleeper.set()
        return
    exit_msg = 'Got signal {0} at frame {1} terminating.'
    logger.info(exit_msg.format(signum, frame))
    sys.exit(0)


def main():
    try:
        usagestr = 'Usage: %prog start|stop|restart options'
        parser = OptionParser(usage=usagestr)
        parser.add_option('-c', '--cred-dir', action='store', type='string', dest='cred_dir',
                          help='Path to credential directory')
        parser.add_option('-l', '--log-file', action='store', type='string',
                          dest='log_file', help='Path to log file')
        parser.add_option('-d', '--debug', action='store_const', dest='log_level',
                          const=logging.DEBUG, default=logging.INFO,
                          help='Set log level to DEBUG')

        (options, args) = parser.parse_args()

        if len(args) != 1:
            parser.print_help()
            sys.exit(1)

        if args[0] == 'start':
            sys.argv = [sys.argv[0], 'start']
        elif args[0] == 'stop':
            sys.argv = [sys.argv[0], 'stop']
        else:
            parser.print_help()
            sys.exit(1)

        cred_dir = get_cred_dir(cred_dir = options.cred_dir)
        logger = setup_logging(log_path = options.log_file, log_level = options.log_level)

        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        logger.info('Starting credmgr and registering signals')

        # catch signals
        signal.signal(signal.SIGHUP, partial(signal_handler, logger))
        signal.signal(signal.SIGTERM, partial(signal_handler, logger))
        signal.signal(signal.SIGINT, partial(signal_handler, logger))
        signal.signal(signal.SIGQUIT, partial(signal_handler, logger))

        app = CredMgrDaemon(logger, cred_dir)
        daemon_runner = DaemonRunner(app)

        handler = logging.handlers.RotatingFileHandler(
                 get_log_file(),
                 backupCount=int(CONFIG.get('logging', 'log-retain')),
                 maxBytes=int(CONFIG.get('logging', 'log-size')))
        handler.setLevel(get_log_level())
        formatter = logging.Formatter(log_format)
        handler.setFormatter(formatter)

        logger.addHandler(handler)
        logger.propagate = False
        logger.info('Logging Started')

        daemon_runner.daemon_context.files_preserve = [
                 handler.stream,
             ]

        logger.info('Administrative operation: %s' % args[0])
        daemon_runner.do_action()
        logger.info('Administrative after action: %s' % args[0])

    except DaemonRunnerStopFailureError as drsfe:
        logger.exception(drsfe)
        logger.propagate = True
        logger.error('Unable to stop service; reason was: %s' % str(drsfe))
        logger.error('Exiting...')
        sys.exit(1)
    except Exception as e:
        logger.exception(e)
        logger.error('Unable to stop service; reason was: %s' % str(e))
        sys.exit(-1)
    sys.exit(0)


if __name__ == '__main__':
    main()